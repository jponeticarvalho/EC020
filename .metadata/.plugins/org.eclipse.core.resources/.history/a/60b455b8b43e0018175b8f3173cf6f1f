/*
 * Command.c
 *
 *  Created on: 03/04/2018
 *      Author: jpone
 */


/*********************************************************
    private constants.
*********************************************************/


/*********************************************************
    private types.
*********************************************************/
typedef enum enum_CommandState
{
	CMMD_WAIT = 0,
	CMMD_VALID,
	CMMD_STRACT_DATA,
	CMMD_PARSE
} tenum_CommandState;

/*********************************************************
    private variable.
*********************************************************/
static tenum_CommandState enumCommandState;

static struct tag_CommandsCtxt
{
	uint8_t  			ucCurrentCommand;
	uint16_t 			uiCurrentCmndSize;
	int 			iCurrentRespLen;
	char* 			pcCurrentData;
	char 			pcBuff[COMMANDS_MAX_BUFF_SIZE];
	char 			pcRespBuff[RESPONSE_MAX_BUFF_SIZE];
}tagCommandsCtxt;

/*********************************************************
    private functions prototypes.
*********************************************************/



/*********************************************************
    private functions.
*********************************************************/


/*********************************************************
    public functions.
*********************************************************/
void command_Init(void)
{
	enu_commandState  = CMND_WAIT;
	tagCommandsCtxt.uiCurrentCmndSize = 0;
	Usart_Ctrl_Init();
}

void command_ProcessLoop(void)
{
	switch (enumCommandState) {
		case CMMD_WAIT:
			tagCommandsCtxt.uiCurrentCmndSize = getData((uint8_t*)tagCommandsCtxt.pcBuff);
			if(tagCommandsCtxt.uiCurrentCmndSize > 0 && tagCommandsCtxt.uiCurrentCmndSize < 512)
			{
				enu_commandState = CMND_VALID;
			}
			break;

		case CMMD_VALID:

			break;

		case CMMD_STRACT_DATA:

			break;

		case CMMD_PARSE:

			break;

		default:
			break;
	}
}

uint16_t getData(uint8_t *pucData){

	uint16_t uiDataSize;

	uiDataSize = InstallerSerialCtrl_getData(pucData);

	return uiDataSize;
}
